
 ## 矩阵的合并与分割

### 矩阵的合并


```python
import numpy as np
```


```python
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
```


```python
x
```




    array([1, 2, 3])




```python
y
```




    array([3, 2, 1])




```python
np.concatenate([x, y])
```




    array([1, 2, 3, 3, 2, 1])




```python
z = np.array([666, 666, 666])
```


```python
np.concatenate([x, y, z])
```




    array([  1,   2,   3,   3,   2,   1, 666, 666, 666])




```python
A = np.array([[1,2,3],[4,5,6]])
```


```python
A
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
np.concatenate([A,A])
```




    array([[1, 2, 3],
           [4, 5, 6],
           [1, 2, 3],
           [4, 5, 6]])




```python
np.concatenate([A,A], axis = 1)
```




    array([[1, 2, 3, 1, 2, 3],
           [4, 5, 6, 4, 5, 6]])




```python
W = np.contenate([A,z])
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-14-325d352b990d> in <module>()
    ----> 1 W = np.contenate([A,z])
    

    AttributeError: module 'numpy' has no attribute 'contenate'



```python
np.concatenate([A,z.reshape(1,-1)])
```




    array([[  1,   2,   3],
           [  4,   5,   6],
           [666, 666, 666]])




```python
np.vstack([A,z])  #竖直方向合并
```




    array([[  1,   2,   3],
           [  4,   5,   6],
           [666, 666, 666]])




```python
B  = np.full((2,2),100)
B
```




    array([[100, 100],
           [100, 100]])




```python
np.hstack([A,B]) #水平方向合并
```




    array([[  1,   2,   3, 100, 100],
           [  4,   5,   6, 100, 100]])



### 矩阵地分割


```python
x = np.arange(10)
x
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
x1, x2, x3 = np.split(x, [3, 7]) # 第一个参数为操作矩阵，第二个对象为分割点
```


```python
x1
```




    array([0, 1, 2])




```python
x2
```




    array([3, 4, 5, 6])




```python
x3
```




    array([7, 8, 9])




```python
x1, x2 = np.split(x,[5])
```


```python
x1
```




    array([0, 1, 2, 3, 4])




```python
x2
```




    array([5, 6, 7, 8, 9])




```python
A = np.arange(16).reshape((4,4))
A
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
A1, A2 = np.split(A,[2])
```


```python
A1
```




    array([[0, 1, 2, 3],
           [4, 5, 6, 7]])




```python
A2
```




    array([[ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
A1, A2 = np.split(A,[2],axis = 1) #竖直方向分割 axis=1
```


```python
A1
```




    array([[ 0,  1],
           [ 4,  5],
           [ 8,  9],
           [12, 13]])




```python
A2
```




    array([[ 2,  3],
           [ 6,  7],
           [10, 11],
           [14, 15]])




```python
np.vsplit(A,[2])
```




    [array([[0, 1, 2, 3],
            [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],
            [12, 13, 14, 15]])]




```python
np.hsplit(A,[2])
```




    [array([[ 0,  1],
            [ 4,  5],
            [ 8,  9],
            [12, 13]]), array([[ 2,  3],
            [ 6,  7],
            [10, 11],
            [14, 15]])]




```python
##数据的分割的意义 将特征值与label分开
```


```python
data = np.arange(16).reshape((4,4))
data
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
X, y = np.hsplit(data,[-1])
```


```python
X
```




    array([[ 0,  1,  2],
           [ 4,  5,  6],
           [ 8,  9, 10],
           [12, 13, 14]])




```python
y
```




    array([[ 3],
           [ 7],
           [11],
           [15]])



## 矩阵的运算


```python
n = 10
L = [i for i in range(n)]
L
```




    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




```python
A = []
for e in L:
    A.append(2*e)
A
```




    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]




```python
n = 1000000
L = [i for i in range(n)]
```


```python
%%time
A = []
for e in L:
    A.append(2*e)
A
```

    Wall time: 192 ms
    


```python
L = np.arange(n)
```


```python
%%time
A = np.array(2*e for e in L)
```

    Wall time: 25.9 ms
    


```python
%%time
A = 2*L
```

    Wall time: 2.99 ms
    


```python
n = 10
L = np.arange(n)
2*L
```




    array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])



### universal Functions


```python
X  = np.arange(1,16).reshape((3,5))
```


```python
X
```




    array([[ 1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10],
           [11, 12, 13, 14, 15]])




```python
X +1
```




    array([[ 2,  3,  4,  5,  6],
           [ 7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16]])




```python
X-1
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
X*2
```




    array([[ 2,  4,  6,  8, 10],
           [12, 14, 16, 18, 20],
           [22, 24, 26, 28, 30]])




```python
X / 2
```




    array([[0.5, 1. , 1.5, 2. , 2.5],
           [3. , 3.5, 4. , 4.5, 5. ],
           [5.5, 6. , 6.5, 7. , 7.5]])




```python
X // 2
```




    array([[0, 1, 1, 2, 2],
           [3, 3, 4, 4, 5],
           [5, 6, 6, 7, 7]], dtype=int32)




```python
X ** 2
```




    array([[  1,   4,   9,  16,  25],
           [ 36,  49,  64,  81, 100],
           [121, 144, 169, 196, 225]], dtype=int32)




```python
1 / X
```




    array([[1.        , 0.5       , 0.33333333, 0.25      , 0.2       ],
           [0.16666667, 0.14285714, 0.125     , 0.11111111, 0.1       ],
           [0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667]])




```python
np.abs(X)
```




    array([[ 1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10],
           [11, 12, 13, 14, 15]])




```python
np.sin(X)
```




    array([[ 0.84147098,  0.90929743,  0.14112001, -0.7568025 , -0.95892427],
           [-0.2794155 ,  0.6569866 ,  0.98935825,  0.41211849, -0.54402111],
           [-0.99999021, -0.53657292,  0.42016704,  0.99060736,  0.65028784]])




```python
np.cos(X)
```




    array([[ 0.54030231, -0.41614684, -0.9899925 , -0.65364362,  0.28366219],
           [ 0.96017029,  0.75390225, -0.14550003, -0.91113026, -0.83907153],
           [ 0.0044257 ,  0.84385396,  0.90744678,  0.13673722, -0.75968791]])




```python
np.tan(X)
```




    array([[ 1.55740772e+00, -2.18503986e+00, -1.42546543e-01,
             1.15782128e+00, -3.38051501e+00],
           [-2.91006191e-01,  8.71447983e-01, -6.79971146e+00,
            -4.52315659e-01,  6.48360827e-01],
           [-2.25950846e+02, -6.35859929e-01,  4.63021133e-01,
             7.24460662e+00, -8.55993401e-01]])




```python
np.exp(X)
```




    array([[2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01,
            1.48413159e+02],
           [4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03,
            2.20264658e+04],
           [5.98741417e+04, 1.62754791e+05, 4.42413392e+05, 1.20260428e+06,
            3.26901737e+06]])




```python
np.power(3,X)
```




    array([[       3,        9,       27,       81,      243],
           [     729,     2187,     6561,    19683,    59049],
           [  177147,   531441,  1594323,  4782969, 14348907]], dtype=int32)




```python
A = np.arange(4).reshape(2,2)
A
```




    array([[0, 1],
           [2, 3]])




```python
B = np.full((2,2),10)
B
```




    array([[10, 10],
           [10, 10]])




```python
A+ B
```




    array([[10, 11],
           [12, 13]])




```python
A - B
```




    array([[-10,  -9],
           [ -8,  -7]])




```python
A * B
```




    array([[ 0, 10],
           [20, 30]])




```python
A.dot(B)#矩阵的乘法
```




    array([[10, 10],
           [50, 50]])




```python
A
```




    array([[0, 1],
           [2, 3]])




```python
A.T#矩阵的转置
```




    array([[0, 2],
           [1, 3]])




```python
C = np.full((3,3),10)
```

### 向量和矩阵运算


```python
v = np.array([1,2])
v
```




    array([1, 2])




```python
A
```




    array([[0, 1],
           [2, 3]])




```python
v + A
```




    array([[1, 3],
           [3, 5]])




```python
np.vstack([v] * A.shape[0]) #改变v的维度
```




    array([[1, 2],
           [1, 2]])




```python
np.vstack([v] * A.shape[0]) + A
```




    array([[1, 3],
           [3, 5]])




```python
np.tile(v, (2, 1))
```




    array([[1, 2],
           [1, 2]])




```python
np.tile(v, (2, 1)) +A
```




    array([[1, 3],
           [3, 5]])




```python
v * A
```




    array([[0, 2],
           [2, 6]])




```python
v.dot(A)
```




    array([4, 7])




```python
A.dot(v) #向量与矩阵相乘，可以自动转置对应的矩阵形式
```




    array([2, 8])



###  矩阵的逆


```python
A
```




    array([[0, 1],
           [2, 3]])




```python
np.linalg.inv(A)
```




    array([[-1.5,  0.5],
           [ 1. ,  0. ]])




```python
invA = np.linalg.inv(A)
```


```python
A.dot(invA)#矩阵必须是方阵才能求逆
```




    array([[1., 0.],
           [0., 1.]])




```python
x = np.arange(16).reshape((2, 8 ))
x
```




    array([[ 0,  1,  2,  3,  4,  5,  6,  7],
           [ 8,  9, 10, 11, 12, 13, 14, 15]])




```python
np.linalg.pinv(x) #求伪逆矩阵
```




    array([[-1.35416667e-01,  5.20833333e-02],
           [-1.01190476e-01,  4.16666667e-02],
           [-6.69642857e-02,  3.12500000e-02],
           [-3.27380952e-02,  2.08333333e-02],
           [ 1.48809524e-03,  1.04166667e-02],
           [ 3.57142857e-02, -7.30583920e-18],
           [ 6.99404762e-02, -1.04166667e-02],
           [ 1.04166667e-01, -2.08333333e-02]])


